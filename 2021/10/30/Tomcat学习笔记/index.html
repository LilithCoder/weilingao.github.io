<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Tomcat学习笔记 | 技术wiki博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Tomcat应用服务器学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat学习笔记">
<meta property="og:url" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="技术wiki博客">
<meta property="og:description" content="Tomcat应用服务器学习">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss3.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss1.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/s12.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss13.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss9.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss7.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss8.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss6.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss10.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss11.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss14.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss15.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss16.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss17.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss18.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss19.png">
<meta property="og:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss2.png">
<meta property="article:published_time" content="2021-10-30T14:09:06.000Z">
<meta property="article:modified_time" content="2021-11-07T14:58:47.546Z">
<meta property="article:author" content="gaoweilin">
<meta property="article:tag" content="Tomcat">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="Servlet容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss3.png">
  
    <link rel="alternate" href="/atom.xml" title="技术wiki博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">技术wiki博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Tomcat学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-10-30T14:09:06.000Z" itemprop="datePublished">2021-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">源码学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Tomcat学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>hi all~<br>开个新坑，打算写一个文档来整理一下tomcat的基础知识</p>
<!-- toc -->

<ul>
<li><a href="#tomcat%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">Tomcat的目录结构</a></li>
<li><a href="#tomcat%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84">Tomcat总体架构</a><ul>
<li><a href="#connector%E5%92%8Ccontainer%E8%A7%A3%E8%80%A6">Connector和Container解耦</a></li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a><ul>
<li><a href="#server">Server</a></li>
<li><a href="#service">Service</a></li>
<li><a href="#connector">Connector</a></li>
<li><a href="#container">Container</a></li>
<li><a href="#engine">Engine</a></li>
<li><a href="#host">Host</a></li>
<li><a href="#context">Context</a></li>
<li><a href="#wrapper">Wrapper</a></li>
</ul>
</li>
<li><a href="#jmx%E5%92%8Cmbean">JMX和Mbean</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#jmx%E7%BB%93%E6%9E%84">JMX结构</a></li>
<li><a href="#jmx-api">JMX API</a></li>
<li><a href="#%E6%A0%87%E5%87%86mbean">标准MBean</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8Bmbean">模型MBean</a></li>
<li><a href="#tomcat%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jmx%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86">Tomcat如何通过JMX实现组件管理</a></li>
</ul>
</li>
<li><a href="#lifecycle">Lifecycle</a><ul>
<li><a href="#lifecycle%E6%8E%A5%E5%8F%A3">Lifecycle接口</a></li>
<li><a href="#lifecyclebase%E7%B1%BB">LifecycleBase类</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F">模板模式</a></li>
</ul>
</li>
<li><a href="#pipeline%E5%92%8Cvalve">Pipeline和Valve</a><ul>
<li><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8Fchain-of-responsibility">责任链模式(Chain of Responsibility)</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1">具体设计</a></li>
</ul>
</li>
<li><a href="#connector%E8%AE%BE%E8%AE%A1">Connector设计</a><ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%9A%84%E8%81%8C%E8%B4%A3">连接器的职责</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1">连接器的设计</a></li>
<li><a href="#coyote%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B">Coyote连接器工作具体流程</a></li>
</ul>
</li>
<li><a href="#executor">Executor</a></li>
<li><a href="#bootstrap">Bootstrap</a></li>
<li><a href="#tomcat%E5%90%AF%E5%8A%A8">Tomcat启动</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86">请求处理</a><ul>
<li><a href="#filterchain">FilterChain</a></li>
</ul>
</li>
<li><a href="#tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">tomcat类加载器</a><ul>
<li><a href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88">加载方案</a></li>
<li><a href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">加载过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#catalina">Catalina</a></li>
</ul>
<!-- tocstop -->

<h1><span id="tomcat的目录结构">Tomcat的目录结构</span></h1><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss3.png"></p>
<h1><span id="tomcat总体架构">Tomcat总体架构</span></h1><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss1.png"><br>*每个组件都有start()和stop()来加载和释放自己维护的资源</p>
<h2><span id="connector和container解耦">Connector和Container解耦</span></h2><p>在Tomcat应用服务器中，会出现面对多种网络协议，但请求处理却相同的情况，当web应用通过tomcat部署时，使用http为客户端提供服务，但当通过apache进行集群部署时候，我们使用AJP协议与web服务器apache进行连接，所以tomcat将网络协议和请求处理解耦</p>
<p>*AJP协议:（Apache JServ Protocol）是定向包协议，使用二进制格式来传输可读性文本。用于Apache和应用程序服务器之间的通信，主要是当tomcat被集成到apache，让apache去处理静态内容时用</p>
<h2><span id="名词解释">名词解释</span></h2><h3><span id="server">Server</span></h3><p>Server表示整个的Catalina Servlet容器，可以包含一个或多个Service组件</p>
<h3><span id="service">Service</span></h3><p>Service是存活在Server内部的中间组件，它将一个或多个连接器（Connector）组件绑定到一个单独的引擎（Engine）上。</p>
<h3><span id="connector">Connector</span></h3><p>连接器（Connector）处理与客户端的通信，它负责接收客户请求，以及向客户返回响应结果</p>
<h3><span id="container">Container</span></h3><p>Container(容器)代表了一类组件，其作用就是处理接收来自客户端的请求并且返回响应数据，具体操作可能会委派到子组件完成，有四个不同的概念级别：Servlet引擎(Engine容器)、虚拟主机(Host容器)、web应用(Context容器)、Servlet(Wrapper容器)</p>
<p>Container组件们还可以通过实现backgroundPross()来进行异步后台处理，比如扫描文件变更</p>
<h3><span id="engine">Engine</span></h3><p>每个Service只能包含一个Servlet引擎（Engine）。引擎表示一个特定的Service的请求处理流水线。作为一个Service可以有多个连接器，引擎从连接器接收和处理所有的请求，当接收到connector的处理请求时，Engine容器能找到一个合适的web应用来处理，并将响应返回给适合的连接器</p>
<h3><span id="host">Host</span></h3><p>Host表示一个虚拟主机，一个引擎可以包含多个Host</p>
<p>举例，一个服务器实例提供多个域名的服务(news.mycompany.com, article.mycompany.com)，每个域名就是一个虚拟主机，每个虚拟主机下包含了多个web应用</p>
<h3><span id="context">Context</span></h3><p>一个Context表示了一个Web应用程序，运行在特定的虚拟主机中</p>
<h3><span id="wrapper">Wrapper</span></h3><p>Wrapper也是一个容器，负责管理一个Servlet</p>
<h2><span id="jmx和mbean">JMX和Mbean</span></h2><p><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/framework/tomcat/tomcat-x-jmx.html">JMX资料参考链接</a></p>
<h3><span id="简介">简介</span></h3><p>JMX的全称为Java Management Extensions，是一个Java平台的管理和监控接口，其定义了管理java对象的公开标准，目的是为了知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等</p>
<p>假设有一个java对象由一个遵循JMX规范的管理器应用程序管理，那这个java对象被称为可由jmx管理的资源，且必须创建一个MBean对象来管理这个对象</p>
<p>MBean会提供一些java对象的属性和方法供管理应用程序使用，但管理应用程序不能访问托管的java对象</p>
<p>当拥有MBean类后，需要将其实例化并注册到MBeanServer上，管理器应用程序通过MBeanServer来访问Mbean实例</p>
<h3><span id="jmx结构">JMX结构</span></h3><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/s12.png"></p>
<ul>
<li><p>Probe Level 负责资源的检测（获取信息），包含MBeans，通常也叫做Instrumentation Level(设备层)</p>
</li>
<li><p>The Agent Level 或者叫做MBean Server（代理服务器），是JMX的核心，连接Mbeans和远程监控程序</p>
</li>
<li><p>Remote Management Level 通过connectors和adaptors来远程操作MBean Server</p>
</li>
</ul>
<h3><span id="jmx-api">JMX API</span></h3><p>MBeanServer(MBean服务器)、ObjectName(用来标识MBean实例)</p>
<p>调用MBeanServer的invoke()可以调用已注册的MBean实例的任何方法，getAttribute()和setAttribute()用于获取和设置已注册的MBean实例的属性</p>
<h3><span id="标准mbean">标准MBean</span></h3><p>通过标准MBean来管理java对象的步骤</p>
<ul>
<li>创建一个接口，命名为java类名+MBean后缀</li>
<li>修改java类，让其实现刚刚创建的xxxMBean接口</li>
<li>创建一个代理，该代理类必须包含一个MBeanServer实例</li>
<li>为MBean创建ObjectName实例</li>
<li>实例化MBeanServer类</li>
<li>将MBean注册到MBeanServer中</li>
</ul>
<h3><span id="模型mbean">模型MBean</span></h3><p>模型MBean不需要定义接口，只需要实现ModelMBean接口，通过ModelMBeanInfo来告诉ModelMBean对象托管资源哪些属性和方法可以暴露给代理</p>
<h3><span id="tomcat如何通过jmx实现组件管理">Tomcat如何通过JMX实现组件管理</span></h3><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss13.png"></p>
<p>MBeanRegistration：Java JMX框架提供的注册MBean的接口，引入此接口是为了便于使用JMX提供的管理功能</p>
<p>JmxEnabled: 此接口由组件实现，这些组件在创建时将注册到MBean服务器，在销毁时将注销这些组件。它主要是由实现生命周期的组件来实现的，但并不是专门为它们实现的</p>
<p>LifecycleMBeanBase：Tomcat提供的对MBeanRegistration的抽象实现类，运用抽象模板模式将所有容器统一注册到JMX</p>
<p>此外，ContainerBase、StandardServer、StandardService、WebappLoader、Connector、StandardContext、StandardEngine、StandardHost、StandardWrapper等容器都继承了LifecycleMBeanBase，因此这些容器都具有了同样的生命周期并可以通过JMX进行管理</p>
<h2><span id="lifecycle">Lifecycle</span></h2><h3><span id="lifecycle接口">Lifecycle接口</span></h3><p>Tomcat核心组件的默认实现继承自LifecycleMBeanBase -&gt; LifecycleBase，依赖结构的顶层是Lifecycle接口</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss9.png"></p>
<p>Lifecycle接口定义了一系列的方法<br><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss7.png"></p>
<p>Tomcat 给各个组件定义了一些生命周期中的状态</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss8.png"></p>
<p>其中状态图是这样的</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss6.png"></p>
<h3><span id="lifecyclebase类">LifecycleBase类</span></h3><p>LifecycleBase是Lifecycle的基本实现</p>
<p>对某个事件注册了监听器的组件必须提供lifecycle接口中3个与监听器相关方法的实现</p>
<p>生命周期监听器保存在一个线程安全的CopyOnWriteArrayList中。所以add和remove都是直接调用此List的相应方法。<br>findLifecycleListeners返回的是一个数组，为了线程安全，所以这儿会生成一个新数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</span><br><span class="line">    <span class="comment">// 这里的入参new LifecycleListener[0]是指存储此List元素的数组</span></span><br><span class="line">    <span class="comment">// 指定的数组能容纳该 List，则返回包含此 List 元素的数组。否则，将根据指定数组的运行时类型和此 List 的大小分配一个新数组</span></span><br><span class="line">    <span class="comment">// 这里给的参数的数组长度是0，因此就会返回包含此 List 中所有元素的数组，并且返回数组的类型与指定数组的运行时类型相同</span></span><br><span class="line">    <span class="keyword">return</span> lifecycleListeners.toArray(<span class="keyword">new</span> LifecycleListener[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">    lifecycleListeners.remove(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LifecycleBase还实现了生命周期相关的方法以及生命周期事件触发的方法，具体实现不细展开了</p>
<h3><span id="模板模式">模板模式</span></h3><p>这里再提一个lifecyclebase涉及的设计模式：模板模式，在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。意图是为了定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<p>比如在生命周期方法init()中调用子类实现的initInternal()</p>
<p>在lifecyclebase有几个模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"><span class="comment">// 启动方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"><span class="comment">// 停止方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"><span class="comment">// 销毁方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">destroyInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br></pre></td></tr></table></figure>
<p>这些方法为为abstract方法，需要继承了lifecycle的组件自行实现</p>
<h2><span id="pipeline和valve">Pipeline和Valve</span></h2><h3><span id="责任链模式chain-of-responsibility">责任链模式(Chain of Responsibility)</span></h3><p>责任链模式（Chain of Responsibility）是一种处理请求的模式，tomcat采用该模式来实现客户端请求的处理，在tomcat中，每个container组件都会通过执行一个职责链来完成具体的请求处理</p>
<h3><span id="具体设计">具体设计</span></h3><p>tomcat定义了pipeline和valve，前者构建职责链，后者代表职责链上的每个处理器，客户端的请求就像流过管道的水，经过每个阀进行处理</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss10.png"></p>
<p>pipeline中维护了一个基础的valve，位于pipeline末端，最后执行，封装了具体的请求处理和输出响应的过程，pipeline通过获得首个valve来启动整个链条的执行</p>
<p>每个层级的容器(Engine, Host, Context, Wrapper)都有对应的基础valve实现，同时维护了一个pipeline实例</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss11.png"></p>
<p>其中涉及的接口和类有Valve接口, Contained接口, Pipeline接口, ValveBase实现类, StandardPipeline实现类</p>
<h2><span id="connector设计">Connector设计</span></h2><h3><span id="连接器的职责">连接器的职责</span></h3><ul>
<li>监听服务器端口，读取来自客户端的请求</li>
<li>将请求数据按照指定协议进行解析</li>
<li>根据请求地址匹配正确的容器进行处理</li>
<li>将响应返回客户端</li>
</ul>
<h3><span id="连接器的设计">连接器的设计</span></h3><p>tomcat支持HTTP和AJP，和多种I/O方式(BIO, NIO, APR)</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss14.png"></p>
<p><em><strong>ProtocolHandler</strong></em></p>
<p>Coyote协议接口，表示一个协议处理器，针对不同协议和i/o方式提供了不同的实现，其包含了一个endpoint用于启动socket监听（AbstractEndPoint按照i/o方式进行分类实现），还包含了一个processor按照协议读取数据，并将请求交给容器处理</p>
<p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss15.png"></p>
<p><em><strong>EndPoint</strong></em></p>
<p>Coyote通信端点，即通信监听的接口，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP/IP协议的</p>
<p><em><strong>Processor</strong></em></p>
<p>Coyote协议处理接口，如果说EndPoint是用来实现TCP/IP协议的，那么Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象</p>
<p><em><strong>适配器Adapter</strong></em></p>
<p>Tomcat通过适配器模式（Adapter）实现了 Connector与Mapper、Container的解轉。Tomcat默认的Connector实现（Coyote）对应的适配器为CoyoteAdapter。</p>
<p>“适配器”在这里的意思，是指“凡是使用coyote连接器的容器，都要实现这个接口，以便从coyote连接器接收请求和响应数据” </p>
<p>由于协议不同，客户端发送过来的请求信息也不尽相同，Tomcat定义了自己的Request类来『存放』这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request不是标准的Servlet Request，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是适配器模式的经典运用，连接器调用CoyoteAdapter的Service方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容器的Service方法</p>
<h3><span id="coyote连接器工作具体流程">Coyote连接器工作具体流程</span></h3><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss16.png"></p>
<p>Coyote封装了底层的网络通信（Socket请求及响应处理），为Catalina容器提供了同一的接口，使Catalina容器与具体的请求协议及IO操作方式完全解耦。Coyote将Socket输入转换封装为Request对象，交由Catalina容器进行处理，处理请求完成后，Catalina通过Coyote提供的Response对象将结果写入输出流</p>
<p>connector启动时，endpoint启动线程来监听服务器端口，并在接收到请求后调用processor进行数据读取，然后按照请求地址映射到具体的容器进行处理，由于tomcat各组件采用通用的生命周期管理，而且可以通过管理工具进行状态变更，因此请求映射除考虑映射规则的实现外，还要考虑容器组件的注册和销毁</p>
<p>Tomcat通过Mapper和MapperListener两个类实现上述功能。前者用于维护容器映射信息，同<br>时按照映射规则（Servlet规范定义）查找容器。后者实现了 ContainerListener 和LifecycleListener, 用于在容器组件状态发生变更时，注册或者取消对应的容器映射信息。为了实现上述功能，MapperListener实现了Lifecycle接口，当其启动时（在Service启动时启动），会自动作为监听器注册到各个容器组件上，同时将已创建的容器注册到Mapper</p>
<h2><span id="executor">Executor</span></h2><p>Tomcat提供了Executor接口来表示一个可以在组件间共享的线程池，该接口同样继承自Lifecycle，可按照通用的组件进行管理。在Tomcat中Executor由 Service维护，因此同一个Service中的组件可以共享一个线程池</p>
<p>如果没有定义任何线程池，相关组件（如Endpoint）会自动创建线程池，此时，线程池不再共享</p>
<p>在Tomcat中，Endpoint会启动一组线程来监听Socket端口，当接收到客户端请求后，会创建<br>请求处理对象，并交由线程池处理，由此支持并发处理客户端请求</p>
<h2><span id="bootstrap">Bootstrap</span></h2><p>Tomcat的几个重要配置文件，其中最核心的文件为server.xml。通过这个文件，我们可以修改Tomcat组件的配置参数甚至添加相关组件，这也是后续性能调优阶段重点涉及的文件</p>
<p>Tomcat提供了 Bootstrap作为应用服务器启动入口。Bootstrap负 责创建Catalina实例，根<br>据执行参数调用Catalina相关方法完成针对应用服务器的操作（启动、停止)</p>
<h2><span id="tomcat启动">Tomcat启动</span></h2><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss17.png"></p>
<h2><span id="请求处理">请求处理</span></h2><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss18.png"></p>
<h3><span id="filterchain">FilterChain</span></h3><p>在软件开发的常接触的责任链模式是FilterChain</p>
<p>Filter 链用 FilterChain 对象表示，FilterChain 对象中有一个 doFilter() 方法，该方法的作用是让 Filter 链上的当前过滤器放行，使请求进入下一个 Filter</p>
<h2><span id="tomcat类加载器">tomcat类加载器</span></h2><h3><span id="加载方案">加载方案</span></h3><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss19.png"></p>
<p>Bootstrap：用于加载JVM提供的基础运行类，即位于%JAVA HOME%/jre/lib目录下的核心类库</p>
<p>Extension： Java提供的标准的扩展机制用于加载除核心类库外的Jar包，即只要复制到指定的扩展目录（可以多个）下的Jar，JVM会自动加载</p>
<p>System：用于加载环境变量CLASSPATH指定目录下的或者-classpath运行参数指定的Jar包（自己编写的类）</p>
<p>Common类加载器：以System为父类加载器，是位于Tomcat应用服务器顶层的公用类加载器，负责加载Tomcat和Web应用都复用的类，其路径为common.loader，默认指向SCATALINA_HOMEAib下的包</p>
<p>Catalina类加载器：负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见。以Common为父加载器，是用于加载Tomcat应用服务器的类加载器，其路径为server.loader，默认为空</p>
<p>Shared类加载器：负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见，以Common为父加载器，是所有web应用的父加载器，其路径为shared.loader, 默认为空</p>
<p>WebApp类加载器：负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见，以Shared为父加载器，加载/WEB-INF/classes目录下的未压缩的Class和资源文件以及/WEB-INF/1ib目录下的Jar包</p>
<h3><span id="加载过程">加载过程</span></h3><p>java默认委派模式加载</p>
<ul>
<li>从缓存中加载</li>
<li>如果缓存中没有，则从父类加载器中加载</li>
<li>如果父类加载器没有，则从当前类加载器加载</li>
<li>如果没有，则拋出;异常</li>
</ul>
<p>web应用类加载器加载顺序</p>
<ul>
<li>从缓存中加载</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载</li>
<li>如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序)</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序为System, Common, Shared</li>
</ul>
<h1><span id="catalina">Catalina</span></h1><p><img src="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ss2.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckvpjzrj3000fw28c9ehi9emo" data-title="Tomcat学习笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet%E5%AE%B9%E5%99%A8/" rel="tag">Servlet容器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/08/11/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">【更新中】MyBatis基础知识整理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/">框架学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">源码学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM%E6%A1%86%E6%9E%B6/" rel="tag">ORM框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet%E5%AE%B9%E5%99%A8/" rel="tag">Servlet容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sequel-pro/" rel="tag">sequel pro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/ORM%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">ORM框架</a> <a href="/tags/Servlet%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Servlet容器</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/sequel-pro/" style="font-size: 10px;">sequel pro</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">后端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/30/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Tomcat学习笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/11/MyBatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">【更新中】MyBatis基础知识整理</a>
          </li>
        
          <li>
            <a href="/2021/06/19/MySQL%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8Aseqeul%20pro%E8%BF%9E%E6%8E%A5/">MySQL的本地搭建以及seqeul pro连接</a>
          </li>
        
          <li>
            <a href="/2021/06/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 gaoweilin<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>